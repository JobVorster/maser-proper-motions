#(*******************************************************
#PROGRAM NAME - relative_pm

#PROGRAMMER - Job Vorster - 2021/02/07

#USAGE - TODO


#DATE - TODO Started 
       #Version 

#BUGS - TODO

#DESCRIPTION - TODO 

#*******************************************************)

#******************************************************************

#        Import all libraries

#*******************************************************************


import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
#Note the utils file should be in your directory.
from utils import extract_from_df,isolate,get_ind,zero_list,err_min,read_data
from glob import glob
from itertools import chain 
from matplotlib import patches as pat
import os
from scipy import stats
import math

#*******************************************************************

#        Define all local functions.

#*******************************************************************



def maser_feature(RA,RAerr,DEC,Decerr,VLSR,xlim,ylim):
    '''Function that averages multiple maser spots (single data points) into maser features. The function takes in 2D lists of uneven shapes
    where the first dimension is the multiple epochs. The second dimension is the individual data points of each epoch. Further the function takes in a box in
    the form of xlim and ylim that isolates the averaging region. Maser spots of the same vlsr are averaged and grouped together for the multiple epochs.
    This makes it quite easy to compute proper motions using the maser features.
    
    Parameters :
    ------------
    RA,RAerr,DEC,Decerr,VLSR : 2D array-like
    Data for all the maser spots generated by maser gaussian fitting.
    xlim,ylim : arraylike of the form [min,max]
    Limits in RA,DEC for which the maser features should be averaged. These limits are generated automatically by the region-identification.py script.
    Make sure that the regions are small enough that different proper motions do not overlap. This might cause large errors in position or unphysical proper motions.
    
    Returns :
    --------
    output : list
    Maser feature data for this box and vlsr, containing information on the average position of the maser feature for all epochs. The list is of the form
    [vlsr,detections,RA,RAerr,DEC,DECerr] - with vlsr being the vlsr of the maser feature (it is assumed to be constant), detections - a string signifying detections and
    RA,...,DECerr which are lists containing the average maser feature information and [99900] if the feature is not detected in that epoch.
    '''
    VLSR_detections = []
    FEATURE_RA = []
    FEATURE_Dec = []
    FEATURE_RAerr = []
    FEATURE_Decerr = []
    for i in range(0,len(RA)):
        inds = isolate(RA[i],DEC[i],xlim,ylim) #indices of maser spots of specific epoch in specified box.
        isoRA = np.array(RA[i])[inds]
        isoRAerr = np.array(RAerr[i])[inds]
        isoDec = np.array(DEC[i])[inds]
        isoDecerr = np.array(Decerr[i])[inds]
        isoVlsr = np.array(VLSR[i])[inds]
        
        del inds
        #With all maser spots in the box isolated - Sort maser spots according to their vlsr so that they 
        #can be averaged.
        VLSR_detections.append(list(dict.fromkeys(isoVlsr)))
        for vlsr in list(dict.fromkeys(isoVlsr)):
            ind = get_ind(isoVlsr,vlsr) #Gets the indices of maser spots of a specific vlsr
            feature_RA = round(np.mean(isoRA[ind]),6) #Averages the RA of the maser spots
            feature_Dec = round(np.mean(isoDec[ind]),6)
            if len(ind) ==1:
                feature_RAerr = 10e-6 #10 microarcseconds error on VERA positioning.
                feature_Decerr = 10e-6
            else:
                feature_RAerr = round(np.std(isoRA[ind])/np.sqrt(len(ind)),6) #Uses error on the mean.
                feature_Decerr = round(np.std(isoDec[ind])/np.sqrt(len(ind)),6)
            
            #Adds the calculated feature's values to a big storage list that stores all the values.
            #The index in the collapsed version of VLSR_detections corresponds to the index of the value
            #in the FEATURE_xx arrays. This will later be used to gather all detections of a specific vlsr over all epochs.
            FEATURE_RA.append(feature_RA)
            FEATURE_Dec.append(feature_Dec)
            FEATURE_RAerr.append(feature_RAerr)
            FEATURE_Decerr.append(feature_Dec)
            
    epoch_Flags = [0] #List containing the first index of a new epoch for the FEATURE_xx arrays.
    total_len = 0
    epoch_indices = []
    
    #Note that we should correct for the VLSR drift in the instrumental measurements. This is the same for all maser spots. The following array
    #is the change in measurement vlsr in terms of the first epoch:
    #[0.0,0.00601999999999947,0.016969999999999708,0.016649999999999388,0.00495000000000001,0.02259000000000011,0.025179999999999758]
    #It should be used to correct the VLSR_detections array.
    #TODO Remember to take this into account with vlsr averaging and writeup.
    #vlsr_correction = [0.0,0.00601999999999947,0.016969999999999708,0.016649999999999388,0.00495000000000001,0.02259000000000011,0.025179999999999758]
    for i in range(0,len(VLSR_detections)):
        if len(VLSR_detections[i])!=0:
            for j in range(0,len(VLSR_detections[i])):
                VLSR_detections[i][j] = round(VLSR_detections[i][j],1) #NOTE that the shift in vlsr is smaller than 0.1 in all epochs. So rounding to the nearest
                                                                       #tenth is a good enough way to judge detections.
            total_len += len(VLSR_detections[i])
            epoch_Flags.append(total_len)
            epoch_indices.append(i)
    #Now the indices [0...Nepochs-1] corresponds to the N+1th epoch.
    
      
      
    #Now we have created maser features from maser spots for all epochs and sorted them according to vlsr.
    #We have to sort all detections so that the maser features of specific vlsr values can be saved together
    #This will be our output that is later used to calculate the proper motions.
    
    epoch_RA = zero_list([0]*len(VLSR_detections),99900)
    epoch_Dec = zero_list([0]*len(VLSR_detections),99900)
    epoch_RAerr = zero_list([0]*len(VLSR_detections),99900)
    epoch_Decerr = zero_list([0]*len(VLSR_detections),99900)
    
    output = []
    detections = list('0'*len(VLSR_detections))
    #print('Epoch flags:' + str(epoch_Flags))
    #print('Epoch indices:' + str(epoch_indices))
    #print("xlim: " + str(xlim) + " ylim: " + str(ylim)) 
    #print("FEATURE_RA: " + str(FEATURE_RA))
    #print("All detected vlsrs: " + str(VLSR_detections))
    for vlsr in list(dict.fromkeys(sum(VLSR_detections,[]))): #Loop over all detected vlsr values.
        ind = get_ind(sum(VLSR_detections,[]),vlsr) #Get all indices corresponding to specific vlsr.
        if len(ind) > 1:
            for k in ind: #Going through each index to get the epoch.
                for i in range(0,len(epoch_Flags)):
                    if k >= epoch_Flags[i] and k < epoch_Flags[i+1]: #The value of i+1 gives the epoch.
                        #This assigns the value of the maser feature to the specified epoch.
                        #TODO THIS IS DEFINITELY BROKEN!
                        epoch_RA[epoch_indices[i]] = FEATURE_RA[k]
                        epoch_Dec[epoch_indices[i]] = FEATURE_Dec[k]
                        epoch_RAerr[epoch_indices[i]] = FEATURE_RAerr[k]
                        epoch_Decerr[epoch_indices[i]] = FEATURE_Decerr[k]
                        detections[epoch_indices[i]] = '1'
        #Finally stores the output that will go into the textfile to calculate the proper motions.
        if ''.join(detections)!= '0'*len(VLSR_detections):
            output.append([vlsr,''.join(detections),epoch_RA,epoch_RAerr,epoch_Dec,epoch_Decerr])
        #Resets the storing arrays.
        detections = list('0'*len(VLSR_detections))
        epoch_RA = zero_list([0]*len(VLSR_detections),99900)
        epoch_Dec = zero_list([0]*len(VLSR_detections),99900)
        epoch_RAerr = zero_list([0]*len(VLSR_detections),99900)
        epoch_Decerr = zero_list([0]*len(VLSR_detections),99900)                
    return output

def read_maser_feature(filename,epCount):
    '''TODO INSERT DOCUMENTATION HERE '''
    vlsr = []
    detections = []
    ra = np.array([])
    raerr = np.array([])
    dec = np.array([])
    decerr =np.array([])
    with open(filename,'r') as f:
        for line in f:
            line_str = line.split(', ')
            vlsr.append(float(line_str[0]))
            detections.append(line_str[1][1:-1])
            del line_str[0:2]
            for i in range(0,len(line_str)):
                element = line_str[i]
                new_element = ''
                for char in element:
                    if not (char == ']' or char == '['):
                        new_element += char
                del element
                line_str[i] = new_element
            ra = np.append(ra,np.array(line_str[0:epCount],dtype = float))
            del line_str[0:epCount]
            raerr = np.append(raerr,np.array(line_str[0:epCount],dtype = float))
            del line_str[0:epCount]
            dec = np.append(dec,np.array(line_str[0:epCount],dtype = float))
            del line_str[0:epCount]
            decerr = np.append(decerr,np.array(line_str[0:epCount],dtype = float))
            del line_str[0:epCount]
    newshape = (len(vlsr),epCount)
    ra = np.reshape(ra.T,newshape)   
    raerr = np.reshape(raerr.T,newshape)
    dec = np.reshape(dec.T,newshape)
    decerr = np.reshape(decerr.T,newshape)
    return vlsr,detections,ra,raerr,dec,decerr

#TODO Complete this function  -- 
def calcpm(mf_RA,mf_RAerr,mf_DEC,mf_DECerr,mf_times,mf_VLSR,mf_DETECTIONS,source_Dec): 
    '''TODO INSERT DOCUMENTATION HERE
    Note that VLSR and detections wont be used in this function code, but will be helpful for the final saving of the data.'''
    datapoint_no = len(mf_RA)
    vlsr = []
    detections = []
    ra = []
    raerr = []
    dec = []
    decerr = []
    mux = []
    muxerr =[]
    muy = []
    muyerr = []
    for datapoint in range(0,datapoint_no):
        fit_RA = []
        fit_DEC = []
        fit_VLSR = []
        fit_times =[]
        for i in range(0,len(mf_RA[datapoint])):
            if mf_RA[datapoint][i] != 99900: #Only uses the data points of detections.
                fit_RA.append(mf_RA[datapoint][i])
                fit_DEC.append(mf_DEC[datapoint][i])
                fit_times.append(mf_times[i])
                fit_VLSR.append(mf_VLSR[datapoint]) # NOTE the mf_VLSR array is only 1D
        dx = fit_RA[-1] - fit_RA[0]  #Get the magnitude of the proper motion from the displacement between the earliest and latest datapoint.
        dt = fit_times[-1] - fit_times[0]
        dy = fit_DEC[-1] - fit_DEC[0]
        linfit = stats.linregress(fit_RA,fit_DEC) #Get the slope and error for the proper motion from linear fit.
        slope,intercept,rvalue,pvalue,stderr = linfit
        mux.append(dx/dt*np.cos(np.deg2rad(source_Dec))) #NOTE The cos delta factor is important for the x component of the proper motion.
        muy.append(math.copysign(1,dy)*np.abs(slope)*np.abs(dx)/dt) #Removes the sign from the slope and dx, but uses the sign from dy.
        ra.append(fit_RA[0])
        dec.append(fit_DEC[0])
        vlsr.append(fit_VLSR[0])
        detections.append(mf_DETECTIONS[datapoint])
        #NOTE Now it is time to consider the errors.
        
        
    return vlsr,ra,raerr,dec,decerr,mux,muxerr,muy,muyerr,detections

#*******************************************************************

#        TODO List for this code and MSc.

#*******************************************************************    


#DONE 1 -- Read in pm_pars and average into maser features.
    #DONE 1.1 -- Iterate over all vlsr for specified box to generate maser feature information 
                #Maser feature information input -- RA,RAerr,Dec,Decerr,VLSR,pm_pars
                #Maser feature information output -- VLSR,detections,RA,RAerr,Dec,Decerr -- Note that RA,Dec,Vlsr will be for all epochs.
                #IDs should be allocated outside maser_feature.
    #DONE 1.2 -- Test the new maser_feature
    #DONE 1.3 -- Make note that the VLSR values change slightly over time.
#TODO 2 -- Fit linear regression line onto maser features and calculate unflagged relative proper motions.
    #DONE 2.1 -- Read maser features from textfile.
    #DONE 2.2 -- Check if maser features are realistic.
    #TODO 2.3 -- Write function calculating relative proper motion using linear fit.
        #DONE 2.3.1 -- Isolate detections and do linear fit.
        #DONE 2.3.2 -- Calculate mux and muy using slopes calculated from linear fit.
        #TODO 2.3.3 -- Calculate sigma_mux and sigma_muy using linear fit and maser_feature errors. NOTE This link has some useful information https://stackoverflow.com/questions/22670057/linear-fitting-in-python-with-uncertainty-in-both-x-and-y-coordinates
        #TODO 2.3.4 -- Save proper motions into text file.
#TODO 3 -- Correct for parallax and galactic rotation.
    #TODO 3.1 -- Correct for peculiar motion.
    #TODO 3.2 -- Correct for galactic rotation.
    #TODO 3.3 -- Correct for parallax.
    #TODO 3.4 -- Correct for motion of reference maser.
#TODO 4 -- Flag bad proper motions.
#TODO 5 -- Use reference maser position to get absolute position.
#TODO A -- Document all calculations
    #TODO A.1 -- Do all comments
        #TODO A.1.1 -- region-identification.py
        #TODO A.1.2 -- relative_pm.py
        #TODO A.1.3 -- pm_flagging.py NOTE check name in github
        #TODO A.1.4 -- pm_correction.py NOTE check name in github.
    #TODO A.2 -- Upload final version to github with explanation.
    #TODO A.3 -- Write up all calculations to MSc method.
    

#*******************************************************************

#        Code main body

#*******************************************************************    
    
    
    
#Note the capitalized versions of list names, these lists are 2D, containing all data of their type. For example, RA contains [ra1,ra2,....] 
RA = []
DEC = []
VLSR = []
FLUX = []
DFLUX = []
#The columns containing the data files in the input.
cols = ['RA','DEC','VLSR','FLUX','DFLUX']
plot_boxes = []
data_boxes = []
plotboxnum = 0
databoxnum = 0


#Reads data from text files into multidimensional arrays.
data_dir = 'VERA-7-epochs'
RA,DEC,VLSR,FLUX,DFLUX = read_data(data_dir,cols)

#VERA positional accuracy is 10 microarcseconds, so all maser spots are initialized with this value:
RAerr = zero_list(RA,10e-6)
Decerr = zero_list(DEC,10e-6)

parameterfile = 'pm_pars.txt' #Filename for the boxes that serve as an input for maser_feature. TODO (Add parameter file name as an input).
if os.path.exists('maser_features.txt'):
    os.remove('maser_features.txt')  #Removes the file before it writes on it again.

#
#TODO Consider adding a heading to the text file.
with open(parameterfile,'r') as f:
    for line in f:
        linestring = np.fromstring(line,dtype = float,sep = ' ,')
        xlim = linestring[0:2]
        ylim = linestring[2:]
        output = maser_feature(RA,RAerr,DEC,Decerr,VLSR,xlim,ylim)
        f2 = open('maser_features.txt','a')
        for single_feature in output:
            f2.write(str(single_feature)[1:-1] + '\n')
        f2.close()

mf_VLSR,mf_DETECTIONS,mf_RA,mf_RAerr,mf_DEC,mf_DECerr = read_maser_feature('maser_features.txt',epCount = len(RA)) #Read maser feature data from textfile. Note the mf_ prefix.


epdate_float = [2014+262.0/365.,2014 + 329./365.,2015 + 31./365.,2015 + 104./365.,2015+322./365.,2016+40./365.,2016+71./365.]
source_Dec = -35*47./60.*1.5/3600.
vlsr,ra,raerr,dec,decerr,mux,muxerr,muy,muyerr,detections = calcpm(mf_RA,mf_RAerr,mf_DEC,mf_DECerr,epdate_float,mf_VLSR,mf_DETECTIONS,source_Dec)

plt.figure(figsize = (7,7))
plotsize =7
aspect_ratio = 4
x_size = plotsize
figsize = (x_size,x_size*aspect_ratio)
newparams = {'figure.figsize': figsize, 'axes.grid': False,
            'lines.linewidth': 1.5, 'lines.markersize': 10,
            'font.size': 14}
plt.rcParams.update(newparams)
plt.gca().invert_xaxis()
plt.quiver(ra,dec,-np.array(mux),muy,vlsr,cmap = 'jet')
plt.xlabel("RA offset (arcsec)")
plt.ylabel("Dec offset (arcsec)")
plt.colorbar(label = r'$V_{LSR}$ (km/s)')
plt.show()

#epdate_str = ["%.2f"%(2014+262.0/365.),"%.2f"%(2014 + 329./365.),"%.2f"%(2015 + 31./365.),
            #"%.2f"%(2015 + 104./365.),"%.2f"%(2015+322./365.),"%.2f"%(2016+40./365.),"%.2f"%(2016+71./365.)]
#clims = [-64.0,0.632865]
#for i in range(0,len(RA)):
    #plt.scatter(np.array(RA[i]),np.array(DEC[i]),c = np.array(VLSR[i]),marker = "$%d$"%(i+1),cmap = 'jet',label = epdates[i])
    #Remember to specify the clim after every plot, and to keep it the same.
    #plt.clim(clims)
#for i in range(0,len(mf_RA)):
    #cm = []
    #for j in range(0,len(mf_VLSR)):
         #cm.append(mf_VLSR[j])              
    #plt.scatter(np.array(mf_RA[i]),np.array(mf_DEC[i]),c = cm,marker = "$%d$"%(i+1),s = 200,cmap = 'jet',label = epdates[i])
    #Remember to specify the clim after every plot, and to keep it the same.
    #plt.clim(clims)
#plt.gca().invert_xaxis()
#plt.show()
