#(*******************************************************
#PROGRAM NAME - relative_pm

#PROGRAMMER - Job Vorster - 2021/02/07

#USAGE - TODO


#DATE - TODO Started 
       #Version 

#BUGS - TODO

#DESCRIPTION - TODO 

#*******************************************************)

#******************************************************************

#        Import all libraries

#*******************************************************************


import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
#Note the utils file should be in your directory.
from utils import extract_from_df,isolate,get_ind,zero_list,err_min,read_data
from glob import glob
from itertools import chain 
from matplotlib import patches as pat
import os
from scipy import stats,optimize
import math

#*******************************************************************

#        Define all local functions.

#*******************************************************************



def maser_feature(RA,RAerr,DEC,Decerr,VLSR,xlim,ylim):
    '''Function that averages multiple maser spots (single data points) into maser features. The function takes in 2D lists of uneven shapes
    where the first dimension is the multiple epochs. The second dimension is the individual data points of each epoch. Further the function takes in a box in
    the form of xlim and ylim that isolates the averaging region. Maser spots of the same vlsr are averaged and grouped together for the multiple epochs.
    This makes it quite easy to compute proper motions using the maser features.
    
    Parameters :
    ------------
    RA,RAerr,DEC,Decerr,VLSR : 2D array-like
    Data for all the maser spots generated by maser gaussian fitting.
    xlim,ylim : arraylike of the form [min,max]
    Limits in RA,DEC for which the maser features should be averaged. These limits are generated automatically by the region-identification.py script.
    Make sure that the regions are small enough that different proper motions do not overlap. This might cause large errors in position or unphysical proper motions.
    
    Returns :
    --------
    output : list
    Maser feature data for this box and vlsr, containing information on the average position of the maser feature for all epochs. The list is of the form
    [vlsr,detections,RA,RAerr,DEC,DECerr] - with vlsr being the vlsr of the maser feature (it is assumed to be constant), detections - a string signifying detections and
    RA,...,DECerr which are lists containing the average maser feature information and [99900] if the feature is not detected in that epoch.
    INDS : 2D list
    List of indices of the dataset that have been used to calculate the maser features. These indices should then be used to delete these data points from the input arrays. 
    To make sure there is no double counts.
    '''
    VLSR_detections = []
    FEATURE_RA = []
    FEATURE_Dec = []
    FEATURE_RAerr = []
    FEATURE_Decerr = []
    INDS = []
    for i in range(0,len(RA)):
        inds = isolate(RA[i],DEC[i],xlim,ylim) #indices of maser spots of specific epoch in specified box.
        INDS.append(inds)
        isoRA = np.array(RA[i])[inds]
        isoRAerr = np.array(RAerr[i])[inds]
        isoDec = np.array(DEC[i])[inds]
        isoDecerr = np.array(Decerr[i])[inds]
        isoVlsr = np.array(VLSR[i])[inds]
        
        del inds
        #With all maser spots in the box isolated - Sort maser spots according to their vlsr so that they 
        #can be averaged.
        VLSR_detections.append(list(dict.fromkeys(isoVlsr)))
        for vlsr in list(dict.fromkeys(isoVlsr)):
            ind = get_ind(isoVlsr,vlsr) #Gets the indices of maser spots of a specific vlsr
            feature_RA = round(np.mean(isoRA[ind]),6) #Averages the RA of the maser spots
            feature_Dec = round(np.mean(isoDec[ind]),6)
            if len(ind) ==1:
                feature_RAerr = 10e-6 #10 microarcseconds error on VERA positioning.
                feature_Decerr = 10e-6
            else:
                feature_RAerr = round(np.std(isoRA[ind])/np.sqrt(len(ind)),6) #Uses error on the mean.
                feature_Decerr = round(np.std(isoDec[ind])/np.sqrt(len(ind)),6)
                
            
            #Adds the calculated feature's values to a big storage list that stores all the values.
            #The index in the collapsed version of VLSR_detections corresponds to the index of the value
            #in the FEATURE_xx arrays. This will later be used to gather all detections of a specific vlsr over all epochs.
            FEATURE_RA.append(feature_RA)
            FEATURE_Dec.append(feature_Dec)
            FEATURE_RAerr.append(feature_RAerr)
            FEATURE_Decerr.append(feature_Decerr)
            
    epoch_Flags = [0] #List containing the first index of a new epoch for the FEATURE_xx arrays.
    total_len = 0
    epoch_indices = []
    
    #Note that we should correct for the VLSR drift in the instrumental measurements. This is the same for all maser spots. The following array
    #is the change in measurement vlsr in terms of the first epoch:
    #[0.0,0.00601999999999947,0.016969999999999708,0.016649999999999388,0.00495000000000001,0.02259000000000011,0.025179999999999758]
    #It should be used to correct the VLSR_detections array.
    #TODO Remember to take this into account with vlsr averaging and writeup.
    #vlsr_correction = [0.0,0.00601999999999947,0.016969999999999708,0.016649999999999388,0.00495000000000001,0.02259000000000011,0.025179999999999758]
    for i in range(0,len(VLSR_detections)):
        if len(VLSR_detections[i])!=0:
            for j in range(0,len(VLSR_detections[i])):
                VLSR_detections[i][j] = round(VLSR_detections[i][j],1) #NOTE that the shift in vlsr is smaller than 0.1 in all epochs. So rounding to the nearest
                                                                       #tenth is a good enough way to judge detections.
            total_len += len(VLSR_detections[i])
            epoch_Flags.append(total_len)
            epoch_indices.append(i)
    #Now the indices [0...Nepochs-1] corresponds to the N+1th epoch.
    
      
      
    #Now we have created maser features from maser spots for all epochs and sorted them according to vlsr.
    #We have to sort all detections so that the maser features of specific vlsr values can be saved together
    #This will be our output that is later used to calculate the proper motions.
    
    epoch_RA = zero_list([0]*len(VLSR_detections),99900)
    epoch_Dec = zero_list([0]*len(VLSR_detections),99900)
    epoch_RAerr = zero_list([0]*len(VLSR_detections),99900)
    epoch_Decerr = zero_list([0]*len(VLSR_detections),99900)
    
    output = []
    detections = list('0'*len(VLSR_detections))
    #print('Epoch flags:' + str(epoch_Flags))
    #print('Epoch indices:' + str(epoch_indices))
    #print("xlim: " + str(xlim) + " ylim: " + str(ylim)) 
    #print("FEATURE_RA: " + str(FEATURE_RA))
    #print("All detected vlsrs: " + str(VLSR_detections))
    for vlsr in list(dict.fromkeys(sum(VLSR_detections,[]))): #Loop over all detected vlsr values.
        ind = get_ind(sum(VLSR_detections,[]),vlsr) #Get all indices corresponding to specific vlsr.
        if len(ind) > 1:
            for k in ind: #Going through each index to get the epoch.
                for i in range(0,len(epoch_Flags)):
                    if k >= epoch_Flags[i] and k < epoch_Flags[i+1]: #The value of i+1 gives the epoch.
                        #This assigns the value of the maser feature to the specified epoch.
                        #TODO THIS IS DEFINITELY BROKEN!
                        epoch_RA[epoch_indices[i]] = FEATURE_RA[k]
                        epoch_Dec[epoch_indices[i]] = FEATURE_Dec[k]
                        epoch_RAerr[epoch_indices[i]] = FEATURE_RAerr[k]
                        epoch_Decerr[epoch_indices[i]] = FEATURE_Decerr[k]
                        detections[epoch_indices[i]] = '1'
        #Finally stores the output that will go into the textfile to calculate the proper motions.
        if ''.join(detections)!= '0'*len(VLSR_detections):
            output.append([vlsr,''.join(detections),epoch_RA,epoch_RAerr,epoch_Dec,epoch_Decerr])
        #Resets the storing arrays.
        detections = list('0'*len(VLSR_detections))
        epoch_RA = zero_list([0]*len(VLSR_detections),99900)
        epoch_Dec = zero_list([0]*len(VLSR_detections),99900)
        epoch_RAerr = zero_list([0]*len(VLSR_detections),99900)
        epoch_Decerr = zero_list([0]*len(VLSR_detections),99900)                
    return output,INDS

def read_maser_feature(filename,epCount):
    '''Reads maser_feature output textfile into arrays that can be manipulated in code.
    Parameters :
    ------------
    filename : string
    Name of the file which the function maser_feature saved its output.
    epCount : int
    Number of epochs in dataset.
    
    Returns :
    --------
    vlsr,detections,ra,raerr,dec,decerr : array-like
    Arrays read from the maser_feature text file.'''
    vlsr = []
    detections = []
    ra = np.array([])
    raerr = np.array([])
    dec = np.array([])
    decerr =np.array([])
    with open(filename,'r') as f:
        for line in f:
            line_str = line.split(', ')
            vlsr.append(float(line_str[0]))
            detections.append(line_str[1][1:-1])
            del line_str[0:2]
            for i in range(0,len(line_str)):
                element = line_str[i]
                new_element = ''
                for char in element:
                    if not (char == ']' or char == '['):
                        new_element += char
                del element
                line_str[i] = new_element
            ra = np.append(ra,np.array(line_str[0:epCount],dtype = float))
            del line_str[0:epCount]
            raerr = np.append(raerr,np.array(line_str[0:epCount],dtype = float))
            del line_str[0:epCount]
            dec = np.append(dec,np.array(line_str[0:epCount],dtype = float))
            del line_str[0:epCount]
            decerr = np.append(decerr,np.array(line_str[0:epCount],dtype = float))
            del line_str[0:epCount]
    newshape = (len(vlsr),epCount)
    ra = np.reshape(ra.T,newshape)   
    raerr = np.reshape(raerr.T,newshape)
    dec = np.reshape(dec.T,newshape)
    decerr = np.reshape(decerr.T,newshape)
    return vlsr,detections,ra,raerr,dec,decerr

def lin_f(x,a,b):
    '''Simple linear function evalueation. With x the dependant variable, a the slope and b the y-intercept. Returns the y value of a specific x value(s)'''
    return a*x+b



def calcpm(mf_RA,mf_RAerr,mf_DEC,mf_DECerr,mf_times,mf_VLSR,mf_DETECTIONS,source_Dec): 
    '''Calculates proper motions from the positions and times of different epochs. The user gives as input the positions of the maser spots
    for different epochs, and their measurement time (in units of years) together with the source declination to calculate proper motions. Note
    that this function works only with the output of maser_feature.
    Parameters :
    ------------
    mf_RA,mf_RAerr,mf_DEC,mf_DECerr,mf_times,mf_VLSR,mf_DETECTIONS : array-like
    Positions, errors, detection times and VLSR and detection arrays of maser features from maser_feature and read_maser_feature.
    source_Dec : float
    Declination of the source in degrees.
    
    Returns:
    -------
    vlsr,ra,raerr,dec,decerr,mux,muxerr,muy,muyerr,detections : array-like
    Information on all detected proper motions.
    
    P.S. Note that VLSR and detections wont be used in this function, but it is helpful to return it to get all data in one line.'''
    
    
    
    #ref_no = 63
    #print(mf_RA[ref_no][1])
    #print(mf_DEC[ref_no][1])
    #for i in range(0,len(mf_RA)):  # NOTE This is a piece of code that tries to move the reference maser position.
        #for j in range(0,len(mf_RA[i])):
            #if mf_RA[i][j] != 99900.0:
                #if mf_RA[ref_no][j] == 99900.0:
                    #mf_RA[i][j] -= mf_ref_no[
                #mf_RA[i][j] -= mf_RA[ref_no][1]
                #mf_DEC[i][j] -= mf_DEC[ref_no][1]
    datapoint_no = len(mf_RA)
    vlsr = []
    detections = []
    ra = []
    raerr = []
    dec = []
    decerr = []
    mux = []
    muxerr =[]
    muy = []
    muyerr = []
    
    for datapoint in range(0,datapoint_no):
        fit_RA = []
        fit_RAerr =[]
        fit_DEC = []
        fit_DECerr = []
        fit_VLSR = []
        fit_times =[]
        for i in range(0,len(mf_RA[datapoint])):
            if mf_RA[datapoint][i] != 99900: #Only uses the data points of detections.
                fit_RA.append(mf_RA[datapoint][i])
                fit_RAerr.append(mf_RAerr[datapoint][i])
                fit_DEC.append(mf_DEC[datapoint][i])
                fit_DECerr.append(mf_DECerr[datapoint][i])
                fit_times.append(mf_times[i])
                fit_VLSR.append(mf_VLSR[datapoint]) # NOTE the mf_VLSR array is only 1D
        dx = fit_RA[-1] - fit_RA[0]  #Get the magnitude of the proper motion from the displacement between the earliest and latest datapoint.
        dt = fit_times[-1] - fit_times[0]
        dy = fit_DEC[-1] - fit_DEC[0]
        popt_RA,pcov_RA = optimize.curve_fit(lin_f,fit_times,fit_RA,sigma = fit_RAerr,absolute_sigma = True)  #Get the slope and error for the proper motion from linear fit.
        perr_RA = np.sqrt(np.diag(pcov_RA)) #Magnitudes of the errors on the parameters.
        popt_DEC,pcov_DEC = optimize.curve_fit(lin_f,fit_times,fit_DEC,sigma = fit_DECerr,absolute_sigma = True)
        perr_DEC = np.sqrt(np.diag(pcov_DEC)) 
        if popt_RA[0]*np.cos(np.deg2rad(source_Dec))*1e3 < 50 and perr_DEC[0]*1e3 < 50 : #NOTE This is the first part of flagging, not saving a data point if the proper motion 
            mux.append(popt_RA[0]*np.cos(np.deg2rad(source_Dec)))                        #is unphysical
            muxerr.append(perr_RA[0]*np.cos(np.deg2rad(source_Dec)))
            muy.append(popt_DEC[0])
            muyerr.append(perr_DEC[0])
            ra.append(fit_RA[0])
            dec.append(fit_DEC[0])
            vlsr.append(fit_VLSR[0])
            detections.append(mf_DETECTIONS[datapoint])
    return vlsr,ra,raerr,dec,decerr,mux,muxerr,muy,muyerr,detections

#*******************************************************************

#        TODO List for this code and MSc.

#*******************************************************************    


#DONE 1 -- Read in pm_pars and average into maser features.
    #DONE 1.1 -- Iterate over all vlsr for specified box to generate maser feature information 
                #Maser feature information input -- RA,RAerr,Dec,Decerr,VLSR,pm_pars
                #Maser feature information output -- VLSR,detections,RA,RAerr,Dec,Decerr -- Note that RA,Dec,Vlsr will be for all epochs.
                #IDs should be allocated outside maser_feature.
    #DONE 1.2 -- Test the new maser_feature
    #DONE 1.3 -- Make note that the VLSR values change slightly over time.
#DONE 2 -- Fit linear regression line onto maser features and calculate unflagged relative proper motions.
    #DONE 2.1 -- Read maser features from textfile.
        #DONE 2.1.A -- Delete maser features from data once they have been calulated. 
    #DONE 2.2 -- Check if maser features are realistic.
    #DONE 2.3 -- Write function calculating relative proper motion using linear fit.
        #DONE 2.3.1 -- Isolate detections and do linear fit.
        #DONE 2.3.2 -- Calculate mux and muy using slopes calculated from linear fit.
        #DONE 2.3.3 -- Calculate sigma_mux and sigma_muy using linear fit and maser_feature errors. 
        #DONE 2.3.4 -- Save proper motions into text file.
#TODO 3 -- Correct for parallax and galactic rotation.
    #TODO 3.1 -- Correct for peculiar motion. NOTE I am not sure if I need to do this.
    #TODO 3.2 -- Correct for galactic rotation. NOTE Look at calculation in pm_correction.py
    #TODO 3.3 -- Correct for parallax.
    #TODO 3.4 -- Correct for motion of reference maser. NOTE Only after AIPS data reduction.
#TODO 4 -- Flag bad proper motions.
#TODO 5 -- Use reference maser position to get absolute position.
#TODO A -- Document all calculations
    #TODO A.1 -- Do all comments
        #TODO A.1.1 -- region-identification.py
        #DONE FOR NOW A.1.2 -- relative_pm.py
        #TODO A.1.3 -- pm_flagging.py NOTE check name in github
        #TODO A.1.4 -- pm_correction.py NOTE check name in github.
        #DONE A.1.5 -- utils.py
    #TODO A.2 -- Upload final version to github with explanation.
    #TODO A.3 -- Write up all calculations to MSc method.
    

#*******************************************************************

#        Code main body

#*******************************************************************    
    
    
    
#Note the capitalized versions of list names, these lists are 2D, containing all data of their type. For example, RA contains [ra1,ra2,....] 
RA = []
DEC = []
VLSR = []
FLUX = []
DFLUX = []
#The columns containing the data files in the input.
cols = ['RA','DEC','VLSR','FLUX','DFLUX']
plot_boxes = []
data_boxes = []
plotboxnum = 0
databoxnum = 0


#Reads data from text files into multidimensional arrays.
data_dir = 'VERA-7-epochs'
RA,DEC,VLSR,FLUX,DFLUX = read_data(data_dir,cols)
#VERA positional accuracy is 10 microarcseconds, so all maser spots are initialized with this value:
RAerr = zero_list(RA,10e-6)
Decerr = zero_list(DEC,10e-6)

parameterfile = 'pm_pars.txt' #Filename for the boxes that serve as an input for maser_feature. TODO (Add parameter file name as an input).
if os.path.exists('maser_features.txt'):
    os.remove('maser_features.txt')  #Removes the file before it writes on it again.


#TODO Consider adding a heading to the text file.
with open(parameterfile,'r') as f:
    for line in f:
        new_RA = []
        new_DEC = []
        new_VLSR = [] #We need to delete the array elements that are used in maser feature to make sure there is no double counting of maser spots.
        new_FLUX = []
        new_DFLUX = []
        linestring = np.fromstring(line,dtype = float,sep = ' ,')
        xlim = linestring[0:2]
        ylim = linestring[2:]
        output,INDS = maser_feature(RA,RAerr,DEC,Decerr,VLSR,xlim,ylim)
        for i in range(0,len(INDS)):
            for j in range(0,len(RA[i])):
                if j not in INDS[i]:
                    new_RA.append(RA[i][j])
                    new_DEC.append(DEC[i][j])
                    new_VLSR.append(VLSR[i][j]) #This counts all the elements that have not been counted by maser_feature.
                    new_FLUX.append(FLUX[i][j])
                    new_DFLUX.append(DFLUX[i][j])
            RA[i] = new_RA
            DEC[i] = new_DEC
            VLSR[i] = new_VLSR #This selects all the values that are NOT in INDS (INDS being the indices of isolated data points).
            FLUX[i] = new_FLUX
            DFLUX[i] = new_DFLUX
            new_RA = []
            new_DEC = []
            new_VLSR = []
            new_FLUX = []
            new_DFLUX = []
        f2 = open('maser_features.txt','a')
        for single_feature in output:
            f2.write(str(single_feature)[1:-1] + '\n')
        f2.close()

mf_VLSR,mf_DETECTIONS,mf_RA,mf_RAerr,mf_DEC,mf_DECerr = read_maser_feature('maser_features.txt',epCount = len(RA)) #Read maser feature data from textfile. Note the mf_ prefix.


epdate_float = [2014+262.0/365.,2014 + 329./365.,2015 + 31./365.,2015 + 104./365.,2015+322./365.,2016+40./365.,2016+71./365.]
source_Dec = -35*47./60.*1.5/3600.

vlsr,ra,raerr,dec,decerr,mux,muxerr,muy,muyerr,detections = calcpm(mf_RA,mf_RAerr,mf_DEC,mf_DECerr,epdate_float,mf_VLSR,mf_DETECTIONS,source_Dec)
#ref_no = 63
#print(len(vlsr))
#del vlsr[ref_no]
#del ra[ref_no]
#del dec[ref_no]
#del mux[ref_no]
#del muy[ref_no] # NOTE This piece of code is part of the code to move the reference maser position.
#del detections[ref_no]

#del raerr[ref_no]
#del decerr[ref_no]
#del muxerr[ref_no]
#del muyerr[ref_no]

plt.figure(figsize = (7,7))
plotsize =7
aspect_ratio = 4
x_size = plotsize
figsize = (x_size,x_size*aspect_ratio)
newparams = {'figure.figsize': figsize, 'axes.grid': False,
            'lines.linewidth': 1.5, 'lines.markersize': 10,
            'font.size': 14}
plt.rcParams.update(newparams)
plt.gca().invert_xaxis()
#print("Index \t Vlsr \t\t RA \t\t DEC \t\t mux (mas) \t muxerr (mas) \t muy (mas) \t muyerr (mas) \t detections \n")
#for i in range(0,len(vlsr)):
#    print("%d \t %0.5f \t %0.5f \t %0.5f \t %0.5f \t %0.5f \t %0.5f \t %0.5f \t %s"%(i,vlsr[i],ra[i],dec[i],mux[i]*1e3,muxerr[i]*1e3,muy[i]*1e3,muyerr[i]*1e3,detections[i]))
    
    
if os.path.exists('pm_results.txt'):
    os.remove('pm_results.txt')  #Removes the file before it writes on it again.
with open("pm_results.txt",'a') as f:
    f.write("Index \t Vlsr \t\t RA \t DEC \t mux (mas) \t muxerr (mas) \t muy (mas) \t muyerr (mas) \t detections \n")
    for i in range(0,len(vlsr)):
        f.write("%d \t %0.5f \t %0.5f \t %0.5f \t %0.5f \t %0.5f \t %0.5f \t %0.5f \t %s\n"%(i,vlsr[i],ra[i],dec[i],mux[i]*1e3,muxerr[i]*1e3,muy[i]*1e3,muyerr[i]*1e3,detections[i]))
f.close()
plt.quiver(ra,dec,-np.array(mux),muy,vlsr,cmap = 'jet')
plt.xlabel("RA offset (arcsec)")
plt.ylabel("Dec offset (arcsec)")
plt.colorbar(label = r'$V_{LSR}$ (km/s)')
plt.show()

#epdate_str = ["%.2f"%(2014+262.0/365.),"%.2f"%(2014 + 329./365.),"%.2f"%(2015 + 31./365.),
            #"%.2f"%(2015 + 104./365.),"%.2f"%(2015+322./365.),"%.2f"%(2016+40./365.),"%.2f"%(2016+71./365.)]
#clims = [-64.0,0.632865]
#for i in range(0,len(RA)):
    #plt.scatter(np.array(RA[i]),np.array(DEC[i]),c = np.array(VLSR[i]),marker = "$%d$"%(i+1),cmap = 'jet',label = epdates[i])
    #Remember to specify the clim after every plot, and to keep it the same.
    #plt.clim(clims)
#for i in range(0,len(mf_RA)):
    #cm = []
    #for j in range(0,len(mf_VLSR)):
         #cm.append(mf_VLSR[j])              
    #plt.scatter(np.array(mf_RA[i]),np.array(mf_DEC[i]),c = cm,marker = "$%d$"%(i+1),s = 200,cmap = 'jet',label = epdates[i])
    #Remember to specify the clim after every plot, and to keep it the same.
    #plt.clim(clims)
#plt.gca().invert_xaxis()
#plt.show()
